"""
DocGenie Agent
Generates comprehensive markdown documentation with diagrams
"""

include:jac ../models/nodes;
include:jac ../models/data_types;
include:jac ../config;

import:py os;
import:py from datetime import, datetime;

walker DocGenie {
    """
    Agent responsible for documentation generation
    - Synthesizes data from RepoMapper and CodeAnalyzer
    - Generates well-organized markdown
    - Creates diagrams using Mermaid
    - Produces final documentation file
    """
    has repo_url: str;
    has repo_info: dict;
    has analysis: dict;
    has session_id: str;
    has status: str = "pending";
    has result: dict = {};
    has errors: list = [];
    has markdown_content: str = "";
    
    can start_generation with `root entry {
        """Start documentation generation"""
        import:py from utils.diagram_generator, DiagramGenerator;
        
        logger.info("[DocGenie] Starting documentation generation");
        
        repo_name = self.repo_info.get("repo_name", "unknown");
        
        # Initialize markdown content
        self.markdown_content = "";
        
        # Generate each section
        self.generate_header(repo_name);
        self.generate_overview();
        self.generate_installation();
        self.generate_architecture();
        
        if INCLUDE_DIAGRAMS {
            self.generate_diagrams();
        }
        
        self.generate_api_reference();
        self.generate_dependencies();
        self.generate_file_structure();
        
        # Save to file
        output_path = self.save_documentation(repo_name);
        
        if output_path {
            self.result = {
                "output_path": output_path,
                "repo_name": repo_name,
                "generated_at": datetime.now().isoformat(),
                "sections_count": len(DOC_SECTIONS)
            };
            self.status = "completed";
            logger.info(f"✓ Documentation saved to {output_path}");
        } else {
            self.errors.append("Failed to save documentation");
            self.status = "failed";
        }
    }
    
    can generate_header(repo_name: str) {
        """Generate documentation header"""
        self.markdown_content += f"# {repo_name} Documentation\n\n";
        self.markdown_content += f"**Generated by Codebase Genius**\n\n";
        self.markdown_content += f"*Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n";
        self.markdown_content += f"*Repository: [{self.repo_url}]({self.repo_url})*\n\n";
        self.markdown_content += "---\n\n";
    }
    
    can generate_overview() {
        """Generate project overview section"""
        self.markdown_content += "## Overview\n\n";
        
        # Add README summary
        readme_summary = self.repo_info.get("readme_summary", "No description available");
        self.markdown_content += f"{readme_summary}\n\n";
        
        # Add statistics
        file_stats = self.repo_info.get("file_stats", {});
        total_files = self.repo_info.get("total_files", 0);
        total_functions = self.analysis.get("total_functions", 0);
        total_classes = self.analysis.get("total_classes", 0);
        
        self.markdown_content += "### Repository Statistics\n\n";
        self.markdown_content += f"- **Total Files:** {total_files}\n";
        self.markdown_content += f"- **Total Functions:** {total_functions}\n";
        self.markdown_content += f"- **Total Classes:** {total_classes}\n";
        self.markdown_content += f"- **Total Lines of Code:** {file_stats.get('total_lines', 0)}\n";
        
        # Languages breakdown
        languages = file_stats.get("languages", {});
        if languages {
            self.markdown_content += "\n### Languages\n\n";
            for lang, stats in languages.items() {
                self.markdown_content += f"- **{lang.title()}:** {stats.get('count', 0)} files, {stats.get('lines', 0)} lines\n";
            }
        }
        
        self.markdown_content += "\n";
    }
    
    can generate_installation() {
        """Generate installation section"""
        self.markdown_content += "## Installation\n\n";
        self.markdown_content += "### Clone the Repository\n\n";
        self.markdown_content += "```bash\n";
        self.markdown_content += f"git clone {self.repo_url}\n";
        
        repo_name = self.repo_info.get("repo_name", "repo");
        self.markdown_content += f"cd {repo_name}\n";
        self.markdown_content += "```\n\n";
        
        # Check for common dependency files
        local_path = self.repo_info.get("local_path", "");
        
        if os.path.exists(os.path.join(local_path, "requirements.txt")) {
            self.markdown_content += "### Python Dependencies\n\n";
            self.markdown_content += "```bash\n";
            self.markdown_content += "pip install -r requirements.txt\n";
            self.markdown_content += "```\n\n";
        }
        
        if os.path.exists(os.path.join(local_path, "package.json")) {
            self.markdown_content += "### Node.js Dependencies\n\n";
            self.markdown_content += "```bash\n";
            self.markdown_content += "npm install\n";
            self.markdown_content += "```\n\n";
        }
    }
    
    can generate_architecture() {
        """Generate architecture section"""
        self.markdown_content += "## Architecture\n\n";
        
        # Entry points
        entry_points = self.repo_info.get("entry_points", []);
        if entry_points {
            self.markdown_content += "### Entry Points\n\n";
            for ep in entry_points {
                ep_name = os.path.basename(ep);
                self.markdown_content += f"- `{ep_name}`\n";
            }
            self.markdown_content += "\n";
        }
        
        # Module structure
        ccg = self.analysis.get("ccg", {});
        modules = ccg.get("modules", {});
        
        if modules {
            self.markdown_content += "### Modules\n\n";
            module_count = min(len(modules), 20);  # Limit to top 20
            for i, (module_name, module_data) in enumerate(list(modules.items())[:module_count]) {
                func_count = len(module_data.get("functions", []));
                class_count = len(module_data.get("classes", []));
                self.markdown_content += f"- **{module_name}**: {func_count} functions, {class_count} classes\n";
            }
            
            if len(modules) > module_count {
                self.markdown_content += f"- *... and {len(modules) - module_count} more modules*\n";
            }
            
            self.markdown_content += "\n";
        }
    }
    
    can generate_diagrams() {
        """Generate diagrams section"""
        import:py from utils.diagram_generator, DiagramGenerator;
        
        self.markdown_content += "## Diagrams\n\n";
        
        diagram_gen = DiagramGenerator(MAX_DIAGRAM_NODES);
        ccg = self.analysis.get("ccg", {});
        
        # Architecture overview diagram
        self.markdown_content += "### Architecture Overview\n\n";
        file_stats = self.repo_info.get("file_stats", {});
        arch_diagram = diagram_gen.generate_architecture_overview(
            self.repo_info.get("total_files", 0),
            self.analysis.get("total_functions", 0),
            self.analysis.get("total_classes", 0),
            file_stats.get("languages", {}),
            self.repo_info.get("entry_points", [])
        );
        self.markdown_content += arch_diagram + "\n";
        
        # Class diagram
        classes = list(ccg.get("classes", {}).values());
        if classes {
            self.markdown_content += "### Class Relationships\n\n";
            class_diagram = diagram_gen.generate_class_diagram(classes[:MAX_DIAGRAM_NODES]);
            self.markdown_content += class_diagram + "\n";
        }
        
        # Function call graph (for top functions)
        functions = list(ccg.get("functions", {}).values())[:MAX_DIAGRAM_NODES];
        relationships = ccg.get("relationships", []);
        
        if functions and relationships {
            self.markdown_content += "### Function Call Graph\n\n";
            # Add source information to relationships
            for rel in relationships {
                for func_key, func_data in ccg.get("functions", {}).items() {
                    if func_data["name"] in rel.get("source", "") {
                        rel["source"] = func_data["name"];
                    }
                    if func_data["name"] in rel.get("target", "") {
                        rel["target"] = func_data["name"];
                    }
                }
            }
            
            call_graph = diagram_gen.generate_function_call_graph(functions, relationships);
            self.markdown_content += call_graph + "\n";
        }
    }
    
    can generate_api_reference() {
        """Generate API reference section"""
        self.markdown_content += "## API Reference\n\n";
        
        ccg = self.analysis.get("ccg", {});
        
        # Classes
        classes = ccg.get("classes", {});
        if classes {
            self.markdown_content += "### Classes\n\n";
            for class_key, class_data in list(classes.items())[:50] {  # Limit to 50
                self.markdown_content += f"#### `{class_data['name']}`\n\n";
                
                if class_data.get("docstring") {
                    self.markdown_content += f"*{class_data['docstring']}*\n\n";
                }
                
                self.markdown_content += f"**File:** `{class_data['file_path']}`\n\n";
                
                if class_data.get("base_classes") {
                    bases = ", ".join(class_data["base_classes"]);
                    self.markdown_content += f"**Inherits from:** {bases}\n\n";
                }
                
                methods = class_data.get("methods", []);
                if methods {
                    self.markdown_content += "**Methods:**\n";
                    for method in methods[:10] {
                        self.markdown_content += f"- `{method}()`\n";
                    }
                    self.markdown_content += "\n";
                }
            }
        }
        
        # Functions
        functions = ccg.get("functions", {});
        if functions {
            self.markdown_content += "### Functions\n\n";
            for func_key, func_data in list(functions.items())[:50] {  # Limit to 50
                params = ", ".join(func_data.get("parameters", []));
                self.markdown_content += f"#### `{func_data['name']}({params})`\n\n";
                
                if func_data.get("docstring") {
                    self.markdown_content += f"*{func_data['docstring']}*\n\n";
                }
                
                self.markdown_content += f"**File:** `{func_data['file_path']}` (Line {func_data['line_number']})\n\n";
                
                if func_data.get("return_type") {
                    self.markdown_content += f"**Returns:** `{func_data['return_type']}`\n\n";
                }
            }
        }
    }
    
    can generate_dependencies() {
        """Generate dependencies section"""
        self.markdown_content += "## Dependencies\n\n";
        
        ccg = self.analysis.get("ccg", {});
        imports = ccg.get("imports", []);
        
        if imports {
            # Extract unique import modules
            unique_imports = set();
            for imp_data in imports {
                import_stmt = imp_data.get("import_statement", "");
                # Extract module name
                if "import " in import_stmt {
                    parts = import_stmt.split();
                    if len(parts) >= 2 {
                        module = parts[1].split('.')[0];
                        unique_imports.add(module);
                }
            }
            
            if unique_imports {
                self.markdown_content += "### External Imports\n\n";
                for module in sorted(unique_imports)[:30] {  # Limit
                    self.markdown_content += f"- `{module}`\n";
                }
                self.markdown_content += "\n";
            }
        }
    }
    
    can generate_file_structure() {
        """Generate file structure section"""
        self.markdown_content += "## File Structure\n\n";
        
        file_tree = self.repo_info.get("file_tree", {});
        if file_tree {
            self.markdown_content += "```\n";
            self.markdown_content += self.format_tree(file_tree, "", True);
            self.markdown_content += "```\n\n";
        }
    }
    
    can format_tree(node: dict, prefix: str, is_last: bool) -> str {
        """Format file tree as text"""
        if not node {
            return "";
        }
        
        result = "";
        connector = "└── " if is_last else "├── ";
        
        name = node.get("name", "");
        node_type = node.get("type", "file");
        
        if node_type == "directory" {
            name = name + "/";
        }
        
        result += prefix + connector + name + "\n";
        
        children = node.get("children", []);
        if children {
            extension = "    " if is_last else "│   ";
            for i, child in enumerate(children[:20]) {  # Limit children
                is_last_child = (i == len(children[:20]) - 1);
                result += self.format_tree(child, prefix + extension, is_last_child);
            }
            
            if len(children) > 20 {
                result += prefix + extension + f"... ({len(children) - 20} more items)\n";
            }
        }
        
        return result;
    }
    
    can save_documentation(repo_name: str) -> str {
        """Save documentation to file"""
        output_dir = os.path.join(OUTPUT_DIR, repo_name);
        os.makedirs(output_dir, exist_ok=True);
        
        output_path = os.path.join(output_dir, "docs.md");
        
        try {
            with open(output_path, 'w', encoding='utf-8') as f {
                f.write(self.markdown_content);
            }
            return output_path;
        } except Exception as e {
            logger.error(f"Error saving documentation: {str(e)}");
            self.errors.append(f"Failed to save documentation: {str(e)}");
            return "";
        }
    }
}