from fastapi import APIRouter, HTTPException
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
from threading import Thread
from uuid import uuid4
from datetime import datetime
from typing import Dict, Any
import time
import os

from ..state import sessions, OUTPUT_DIR

router = APIRouter()


class GenerateDocsRequest(BaseModel):
    repo_url: str


def _simulate_processing(session_id: str, repo_url: str) -> None:
    """Simulate the walker pipeline and write a docs.md file when done."""
    try:
        sessions[session_id]["status"] = "running"
        sessions[session_id]["current_stage"] = "repo_mapping"
        time.sleep(1.0)  # simulate work

        sessions[session_id]["current_stage"] = "analysis"
        time.sleep(1.0)

        sessions[session_id]["current_stage"] = "generating_docs"
        time.sleep(1.0)

        # Create a placeholder final_docs
        repo_name = sessions[session_id].get("repo_name", "repo")
        final_docs = (
            f"# Documentation for {repo_name}\n\n"
            f"Repository: {repo_url}\n\n"
            f"Generated at: {datetime.utcnow().isoformat()}Z\n\n"
            "## Summary\n\nThis is placeholder documentation generated by the Code Genius API.\n"
        )

        # Save file
        out_dir = OUTPUT_DIR / repo_name
        out_dir.mkdir(parents=True, exist_ok=True)
        out_file = out_dir / "docs.md"
        out_file.write_text(final_docs, encoding="utf-8")

        sessions[session_id]["final_docs"] = str(out_file)
        sessions[session_id]["status"] = "completed"
        sessions[session_id]["progress"] = 100.0
        sessions[session_id]["current_stage"] = "done"
    except Exception as exc:
        sessions[session_id]["status"] = "failed"
        sessions[session_id]["errors"].append(str(exc))


@router.post("/generate_docs")
def generate_docs(request: GenerateDocsRequest) -> Dict[str, Any]:
    # Basic validation
    if not request.repo_url or not request.repo_url.startswith(("http://", "https://", "git@")):
        raise HTTPException(status_code=400, detail="Invalid repo_url")

    session_id = str(uuid4())
    repo_name = os.path.splitext(os.path.basename(request.repo_url.rstrip("/")))[0] or "repo"

    sessions[session_id] = {
        "session_id": session_id,
        "repo_url": request.repo_url,
        "repo_name": repo_name,
        "status": "initiated",
        "progress": 0.0,
        "current_stage": "validation",
        "errors": [],
        "created_at": datetime.utcnow().isoformat(),
        "final_docs": "",
    }

    # Start background processing thread
    thread = Thread(target=_simulate_processing, args=(session_id, request.repo_url), daemon=True)
    thread.start()

    return {"status": "initiated", "session_id": session_id, "repo_name": repo_name}


@router.get("/status/{session_id}")
def get_status(session_id: str) -> Dict[str, Any]:
    session = sessions.get(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    return session


@router.get("/sessions")
def list_sessions() -> Dict[str, Any]:
    return {"sessions": list(sessions.values()), "total": len(sessions)}


@router.get("/download/{session_id}")
def download_docs(session_id: str):
    session = sessions.get(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    if session.get("status") != "completed":
        raise HTTPException(status_code=400, detail=f"Documentation not ready. Status: {session.get('status')}")
    final_path = session.get("final_docs")
    if not final_path or not os.path.exists(final_path):
        raise HTTPException(status_code=404, detail="Documentation file not found")
    return FileResponse(final_path, media_type="text/markdown", filename=os.path.basename(final_path))
